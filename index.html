<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="description" content="Castle Defense 3D - Epic tower defense game with Three.js">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Castle Defense 3D</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icons/icon.svg">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Cinzel', serif;
            background: #0a0a15;
            color: #f0e6d3;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas { display: block; }

        .hud { position: absolute; pointer-events: none; }
        .hud > * { pointer-events: auto; }

        #top-hud {
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
            flex-wrap: wrap;
        }

        .resource-bar {
            display: flex;
            gap: 15px;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #ffd700;
        }
        .resource { display: flex; align-items: center; gap: 5px; font-size: 14px; }
        .resource-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; }
        .gold-icon { color: #ffd700; }
        .health-icon { color: #44ff44; }
        .mana-icon { color: #4488ff; }

        #wave-info {
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #8b0000;
            text-align: center;
        }

        #tower-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: center;
            gap: 5px;
            flex-wrap: wrap;
        }
        .tower-btn {
            width: 60px;
            height: 70px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 5px;
        }
        .tower-btn:hover, .tower-btn.selected {
            border-color: #ffd700;
            transform: scale(1.05);
            background: rgba(40,40,60,0.95);
        }
        .tower-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        .tower-btn .icon { font-size: 24px; margin-bottom: 2px; }
        .tower-btn .name { font-size: 8px; text-transform: uppercase; }
        .tower-btn .cost { font-size: 10px; color: #ffd700; }

        #skills-panel {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .skill-btn {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #4488ff;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            transition: all 0.2s;
        }
        .skill-btn:hover:not(.cooldown) { transform: scale(1.1); border-color: #88aaff; }
        .skill-btn.cooldown { opacity: 0.5; cursor: not-allowed; }
        .skill-btn .cd-overlay {
            position: absolute;
            bottom: -5px;
            font-size: 10px;
            background: rgba(0,0,0,0.8);
            padding: 1px 4px;
            border-radius: 3px;
        }

        #game-controls {
            position: absolute;
            top: 60px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-btn {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #666;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
        }
        .control-btn:hover { border-color: #ffd700; }
        .control-btn.active { background: rgba(100,50,50,0.9); border-color: #ff4444; }

        #tower-info {
            position: absolute;
            display: none;
            background: rgba(0,0,0,0.95);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            z-index: 100;
        }
        #tower-info.visible { display: block; }
        #tower-info h3 { color: #ffd700; margin-bottom: 10px; font-size: 16px; }
        #tower-info .stat { display: flex; justify-content: space-between; margin: 5px 0; font-size: 12px; }
        #tower-info .upgrade-btn {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: linear-gradient(180deg, #4a7c2a, #2d4a1a);
            border: 2px solid #6a9c4a;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            font-family: inherit;
        }
        #tower-info .sell-btn {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            background: linear-gradient(180deg, #8b2222, #5a1111);
            border: 2px solid #aa4444;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            font-family: inherit;
        }

        #start-wave-btn {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            font-size: 18px;
            font-family: inherit;
            background: linear-gradient(180deg, #8b0000, #5a0000);
            border: 3px solid #ff4444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px #ff4444; }
            50% { box-shadow: 0 0 25px #ff4444; }
        }

        #message-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }
        .game-message {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700, 2px 2px 4px #000;
            animation: messageIn 0.5s ease-out;
        }
        @keyframes messageIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        .overlay-screen.visible { display: flex; }
        .overlay-screen h1 {
            font-size: 64px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px currentColor;
        }
        .overlay-screen.victory h1 { color: #ffd700; }
        .overlay-screen.defeat h1 { color: #ff4444; }
        .overlay-screen .stats { font-size: 24px; margin: 20px 0; }
        .overlay-screen button {
            padding: 15px 50px;
            font-size: 24px;
            font-family: inherit;
            background: linear-gradient(180deg, #4a4a7a, #2a2a4a);
            border: 3px solid #8888cc;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            margin-top: 20px;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a15;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }
        #loading-screen h1 { font-size: 48px; color: #ffd700; margin-bottom: 30px; }
        .loading-bar {
            width: 300px;
            height: 20px;
            background: #222;
            border: 2px solid #ffd700;
            border-radius: 10px;
            overflow: hidden;
        }
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffaa00);
            width: 0%;
            transition: width 0.3s;
        }
        #loading-text { margin-top: 15px; color: #888; }

        @media (max-width: 768px) {
            .tower-btn { width: 50px; height: 60px; }
            .tower-btn .icon { font-size: 20px; }
            .tower-btn .name { font-size: 7px; }
            .skill-btn { width: 45px; height: 45px; }
            .resource { font-size: 12px; }
            #start-wave-btn { padding: 12px 30px; font-size: 14px; }
        }

        /* Main Menu Styles */
        #menuScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(180deg, #0a0a15 0%, #1a1a2e 50%, #0f0f23 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }
        .menu-content {
            text-align: center;
            padding: 40px;
        }
        #menuScreen h1 {
            font-size: clamp(36px, 10vw, 72px);
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255,215,0,0.5), 0 4px 8px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 40px;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            margin-bottom: 40px;
        }
        .menu-btn {
            padding: 18px 60px;
            font-size: 22px;
            font-weight: bold;
            background: linear-gradient(180deg, #8b6914 0%, #5a4510 100%);
            border: 3px solid #ffd700;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 280px;
            font-family: inherit;
        }
        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255,215,0,0.6);
        }
        .menu-btn.secondary {
            background: linear-gradient(180deg, #3a3a4a 0%, #2a2a3a 100%);
            border-color: #888;
        }
        .game-info {
            color: #888;
            font-size: 14px;
        }
        .game-info p {
            margin: 8px 0;
        }
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 400;
        }
        .modal-content {
            background: linear-gradient(180deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 30px 40px;
            max-width: 400px;
            text-align: left;
        }
        .modal-content h2 {
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
        }
        .modal-content ul {
            list-style: none;
            padding: 0;
        }
        .modal-content li {
            margin: 12px 0;
            color: #ccc;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <!-- Main Menu Screen -->
    <div id="menuScreen">
        <div class="menu-content">
            <h1>CASTLE DEFENSE 3D</h1>
            <p class="subtitle">Defend your kingdom against waves of enemies!</p>
            <div class="menu-buttons">
                <button class="menu-btn" id="startGameBtn">START GAME</button>
                <button class="menu-btn secondary" id="howToPlayBtn">HOW TO PLAY</button>
            </div>
            <div class="game-info">
                <p>Place towers to defend the castle</p>
                <p>Earn gold by defeating enemies</p>
                <p>Survive 15 waves to win!</p>
            </div>
        </div>
    </div>

    <!-- How To Play Modal -->
    <div id="howToPlayModal" class="modal hidden">
        <div class="modal-content">
            <h2>How To Play</h2>
            <ul>
                <li><strong>Click</strong> a tower button to select it</li>
                <li><strong>Click</strong> on the ground to place towers</li>
                <li><strong>Towers</strong> automatically attack enemies in range</li>
                <li><strong>Skills (1-4)</strong> for special abilities</li>
                <li><strong>Don't let enemies reach the castle!</strong></li>
            </ul>
            <button class="menu-btn" id="closeHowTo">Got it!</button>
        </div>
    </div>

    <div id="game-container">
        <div id="loading-screen">
            <h1>Castle Defense 3D</h1>
            <div class="loading-bar"><div class="loading-fill" id="loading-fill"></div></div>
            <div id="loading-text">Initializing...</div>
        </div>

        <div class="hud" id="top-hud">
            <div class="resource-bar">
                <div class="resource"><span class="resource-icon gold-icon">&#128176;</span><span id="gold-display">200</span></div>
                <div class="resource"><span class="resource-icon health-icon">&#10084;</span><span id="health-display">100</span></div>
                <div class="resource"><span class="resource-icon mana-icon">&#9889;</span><span id="mana-display">100</span></div>
            </div>
            <div id="wave-info"><div>Wave <span id="wave-display">0</span> / 15</div></div>
        </div>

        <div id="tower-panel"></div>
        <div id="skills-panel"></div>
        <div id="game-controls">
            <button class="control-btn" id="pause-btn" title="Pause">&#9208;</button>
            <button class="control-btn" id="speed-btn" title="Speed">1x</button>
        </div>

        <button id="start-wave-btn">Start Wave</button>

        <div id="tower-info">
            <h3 id="tower-info-name">Tower</h3>
            <div class="stat"><span>Level:</span><span id="tower-info-level">1</span></div>
            <div class="stat"><span>Damage:</span><span id="tower-info-damage">10</span></div>
            <div class="stat"><span>Range:</span><span id="tower-info-range">3</span></div>
            <div class="stat"><span>Speed:</span><span id="tower-info-speed">1.0</span></div>
            <div class="stat"><span>Kills:</span><span id="tower-info-kills">0</span></div>
            <button class="upgrade-btn" id="upgrade-btn">Upgrade (50g)</button>
            <button class="sell-btn" id="sell-btn">Sell (25g)</button>
        </div>

        <div id="message-area"></div>

        <div class="overlay-screen victory" id="victory-screen">
            <h1>Victory!</h1>
            <div class="stats">
                <div>Waves Completed: 15</div>
                <div>Total Kills: <span id="victory-kills">0</span></div>
                <div>Final Gold: <span id="victory-gold">0</span></div>
            </div>
            <button onclick="location.reload()">Play Again</button>
        </div>

        <div class="overlay-screen defeat" id="defeat-screen">
            <h1>Defeat!</h1>
            <div class="stats">
                <div>Reached Wave: <span id="defeat-wave">0</span></div>
                <div>Total Kills: <span id="defeat-kills">0</span></div>
            </div>
            <button onclick="location.reload()">Try Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    const CONFIG = {
        GRID_SIZE: 12,
        CELL_SIZE: 3,
        MAX_WAVES: 15,
        STARTING_GOLD: 200,
        STARTING_HEALTH: 100,
        STARTING_MANA: 100,
        MAX_MANA: 150,
        MANA_REGEN: 0.5
    };

    const TOWERS = {
        archer: { name: 'Archer', icon: '&#127993;', cost: 40, damage: 12, range: 4, attackSpeed: 1.0, color: 0x8b4513 },
        wizard: { name: 'Wizard', icon: '&#128302;', cost: 80, damage: 20, range: 3.5, attackSpeed: 0.7, color: 0x4b0082, special: 'splash' },
        frost: { name: 'Frost', icon: '&#10052;', cost: 70, damage: 8, range: 3, attackSpeed: 0.9, color: 0x00bfff, special: 'slow' },
        cannon: { name: 'Cannon', icon: '&#128163;', cost: 100, damage: 40, range: 3, attackSpeed: 0.4, color: 0x2f2f2f, special: 'aoe' },
        dragon: { name: 'Dragon', icon: '&#128009;', cost: 180, damage: 30, range: 4, attackSpeed: 0.6, color: 0xff4500, special: 'burn' },
        lightning: { name: 'Lightning', icon: '&#9889;', cost: 150, damage: 25, range: 5, attackSpeed: 1.2, color: 0xffff00, special: 'chain' },
        poison: { name: 'Poison', icon: '&#9760;', cost: 85, damage: 6, range: 3, attackSpeed: 0.5, color: 0x32cd32, special: 'dot' },
        ballista: { name: 'Ballista', icon: '&#127919;', cost: 120, damage: 60, range: 6, attackSpeed: 0.25, color: 0x8b0000, special: 'pierce' },
        mortar: { name: 'Mortar', icon: '&#128165;', cost: 130, damage: 45, range: 5, attackSpeed: 0.35, color: 0x4a4a4a, special: 'stun' },
        tesla: { name: 'Tesla', icon: '&#127785;', cost: 160, damage: 15, range: 4, attackSpeed: 1.8, color: 0x00ffff, special: 'arc' }
    };

    const ENEMIES = {
        goblin: { name: 'Goblin', health: 80, speed: 1.2, reward: 10, color: 0x44aa44 },
        orc: { name: 'Orc', health: 150, speed: 0.8, reward: 15, color: 0x448844 },
        skeleton: { name: 'Skeleton', health: 60, speed: 1.5, reward: 8, color: 0xccccaa },
        wolf: { name: 'Wolf', health: 100, speed: 2.0, reward: 12, color: 0x666666 },
        troll: { name: 'Troll', health: 500, speed: 0.5, reward: 50, armor: 8, color: 0x558855 },
        darkKnight: { name: 'Dark Knight', health: 400, speed: 0.7, reward: 30, armor: 15, color: 0x222233 },
        necromancer: { name: 'Necromancer', health: 150, speed: 0.9, reward: 25, shield: 80, color: 0x440044 },
        dragon: { name: 'Dragon', health: 1200, speed: 0.6, reward: 100, armor: 20, color: 0xaa2222 },
        demon: { name: 'Demon', health: 800, speed: 0.8, reward: 80, color: 0x880000 },
        lich: { name: 'Lich', health: 500, speed: 0.7, reward: 60, shield: 150, color: 0x220044 },
        golem: { name: 'Golem', health: 1000, speed: 0.3, reward: 70, armor: 25, color: 0x555566 },
        boss: { name: 'Dark Lord', health: 4000, speed: 0.4, reward: 500, armor: 30, shield: 300, color: 0x110022 }
    };

    const SKILLS = {
        meteor: { name: 'Meteor', icon: '&#9732;', manaCost: 40, damage: 200, radius: 3, cooldown: 15 },
        blizzard: { name: 'Blizzard', icon: '&#127784;', manaCost: 30, duration: 5, slowAmount: 0.5, cooldown: 20 },
        heal: { name: 'Heal', icon: '&#128154;', manaCost: 25, healAmount: 20, cooldown: 30 },
        rage: { name: 'Rage', icon: '&#128293;', manaCost: 50, damageBoost: 2, duration: 10, cooldown: 45 }
    };

    const WAVES = [
        { enemies: [{ type: 'goblin', count: 5 }], delay: 1000 },
        { enemies: [{ type: 'goblin', count: 8 }, { type: 'orc', count: 2 }], delay: 900 },
        { enemies: [{ type: 'skeleton', count: 10 }, { type: 'wolf', count: 3 }], delay: 800 },
        { enemies: [{ type: 'orc', count: 8 }, { type: 'skeleton', count: 5 }], delay: 800 },
        { enemies: [{ type: 'troll', count: 2 }, { type: 'goblin', count: 10 }], delay: 700 },
        { enemies: [{ type: 'darkKnight', count: 5 }, { type: 'skeleton', count: 8 }], delay: 700 },
        { enemies: [{ type: 'necromancer', count: 3 }, { type: 'skeleton', count: 15 }], delay: 600 },
        { enemies: [{ type: 'wolf', count: 12 }, { type: 'orc', count: 8 }], delay: 600 },
        { enemies: [{ type: 'troll', count: 4 }, { type: 'darkKnight', count: 6 }], delay: 500 },
        { enemies: [{ type: 'demon', count: 3 }, { type: 'necromancer', count: 5 }], delay: 500 },
        { enemies: [{ type: 'dragon', count: 2 }, { type: 'demon', count: 4 }], delay: 500 },
        { enemies: [{ type: 'lich', count: 4 }, { type: 'golem', count: 3 }], delay: 400 },
        { enemies: [{ type: 'dragon', count: 3 }, { type: 'darkKnight', count: 10 }], delay: 400 },
        { enemies: [{ type: 'golem', count: 5 }, { type: 'lich', count: 5 }, { type: 'demon', count: 5 }], delay: 300 },
        { enemies: [{ type: 'boss', count: 1 }, { type: 'dragon', count: 2 }, { type: 'demon', count: 5 }], delay: 300 }
    ];

    const gameState = {
        gold: CONFIG.STARTING_GOLD,
        health: CONFIG.STARTING_HEALTH,
        mana: CONFIG.STARTING_MANA,
        wave: 0,
        waveActive: false,
        paused: false,
        gameSpeed: 1,
        totalKills: 0,
        selectedTowerType: null,
        selectedTower: null,
        towers: [],
        enemies: [],
        projectiles: [],
        skillCooldowns: {},
        rageActive: false,
        rageEndTime: 0,
        blizzardActive: false,
        blizzardEndTime: 0
    };

    const PATH = [
        { x: 0, z: 6 }, { x: 1, z: 6 }, { x: 2, z: 6 }, { x: 3, z: 6 },
        { x: 3, z: 5 }, { x: 3, z: 4 }, { x: 3, z: 3 },
        { x: 4, z: 3 }, { x: 5, z: 3 }, { x: 6, z: 3 },
        { x: 6, z: 4 }, { x: 6, z: 5 }, { x: 6, z: 6 }, { x: 6, z: 7 }, { x: 6, z: 8 },
        { x: 7, z: 8 }, { x: 8, z: 8 },
        { x: 8, z: 7 }, { x: 8, z: 6 }, { x: 8, z: 5 },
        { x: 9, z: 5 }, { x: 10, z: 5 }, { x: 11, z: 5 }
    ];

    let scene, camera, renderer, raycaster, mouse;
    let gridCells = [], starField, dustParticles, castleMesh;

    function initThreeJS() {
        updateLoadingProgress(10, 'Creating scene...');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.008);

        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
        const centerX = (CONFIG.GRID_SIZE * CONFIG.CELL_SIZE) / 2;
        camera.position.set(centerX, 45, CONFIG.GRID_SIZE * CONFIG.CELL_SIZE + 25);
        camera.lookAt(centerX, 0, (CONFIG.GRID_SIZE * CONFIG.CELL_SIZE) / 2);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('loading-screen'));

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        updateLoadingProgress(20, 'Creating sky...');
        createSkyDome();
        updateLoadingProgress(30, 'Creating stars...');
        createStarField();
        updateLoadingProgress(40, 'Setting up lights...');
        createLighting();
        updateLoadingProgress(50, 'Creating terrain...');
        createGround();
        updateLoadingProgress(60, 'Building path...');
        createPath();
        updateLoadingProgress(70, 'Placing grid...');
        createGrid();
        updateLoadingProgress(80, 'Constructing castle...');
        createCastle();
        updateLoadingProgress(85, 'Adding environment...');
        createEnvironment();
        updateLoadingProgress(90, 'Creating particles...');
        createDustParticles();
        updateLoadingProgress(100, 'Ready!');
        setTimeout(() => { document.getElementById('loading-screen').style.display = 'none'; }, 500);
    }

    function updateLoadingProgress(percent, text) {
        document.getElementById('loading-fill').style.width = percent + '%';
        document.getElementById('loading-text').textContent = text;
    }

    function createSkyDome() {
        const skyGeo = new THREE.SphereGeometry(400, 32, 32);
        const skyMat = new THREE.ShaderMaterial({
            uniforms: { topColor: { value: new THREE.Color(0x0a0a20) }, bottomColor: { value: new THREE.Color(0x1a1a3a) } },
            vertexShader: `varying vec3 vWorldPosition; void main() { vec4 worldPosition = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPosition.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `uniform vec3 topColor; uniform vec3 bottomColor; varying vec3 vWorldPosition; void main() { float h = normalize(vWorldPosition).y; gl_FragColor = vec4(mix(bottomColor, topColor, max(h, 0.0)), 1.0); }`,
            side: THREE.BackSide
        });
        scene.add(new THREE.Mesh(skyGeo, skyMat));
    }

    function createStarField() {
        const starsGeo = new THREE.BufferGeometry();
        const starPositions = [], starColors = [];
        for (let i = 0; i < 1500; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 0.8 + 0.1);
            const r = 350 + Math.random() * 30;
            starPositions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi) + 50, r * Math.sin(phi) * Math.sin(theta));
            const brightness = 0.5 + Math.random() * 0.5;
            starColors.push(brightness, brightness, brightness * 0.9);
        }
        starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starsGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        starField = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, opacity: 0.8 }));
        scene.add(starField);
    }

    function createLighting() {
        scene.add(new THREE.AmbientLight(0x404060, 0.4));
        const moonLight = new THREE.DirectionalLight(0xaabbff, 0.6);
        moonLight.position.set(-50, 80, 30);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 2048;
        moonLight.shadow.mapSize.height = 2048;
        moonLight.shadow.camera.near = 10;
        moonLight.shadow.camera.far = 200;
        moonLight.shadow.camera.left = -60;
        moonLight.shadow.camera.right = 60;
        moonLight.shadow.camera.top = 60;
        moonLight.shadow.camera.bottom = -60;
        scene.add(moonLight);
        const fillLight = new THREE.DirectionalLight(0xffaa66, 0.3);
        fillLight.position.set(30, 40, -20);
        scene.add(fillLight);
    }

    function createGround() {
        const gridWorldSize = CONFIG.GRID_SIZE * CONFIG.CELL_SIZE;
        const groundGeo = new THREE.PlaneGeometry(gridWorldSize + 40, gridWorldSize + 40, 64, 64);
        const positions = groundGeo.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            positions[i + 2] = Math.sin(positions[i] * 0.1) * Math.cos(positions[i + 1] * 0.1) * 0.5 + Math.random() * 0.2;
        }
        groundGeo.computeVertexNormals();
        const groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.9 }));
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.set(gridWorldSize / 2, -0.1, gridWorldSize / 2);
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function createPath() {
        const pathMat = new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 0.8 });
        PATH.forEach(point => {
            const pathMesh = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.CELL_SIZE - 0.1, 0.15, CONFIG.CELL_SIZE - 0.1), pathMat);
            pathMesh.position.set(point.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2, 0.08, point.z * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2);
            pathMesh.receiveShadow = true;
            scene.add(pathMesh);
        });
    }

    function createGrid() {
        const pathSet = new Set(PATH.map(p => `${p.x},${p.z}`));
        for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
            for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
                if (pathSet.has(`${x},${z}`)) continue;
                const cell = new THREE.Mesh(
                    new THREE.BoxGeometry(CONFIG.CELL_SIZE - 0.2, 0.1, CONFIG.CELL_SIZE - 0.2),
                    new THREE.MeshStandardMaterial({ color: 0x1a2a1a, transparent: true, opacity: 0.3 })
                );
                cell.position.set(x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2, 0.05, z * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2);
                cell.userData = { gridX: x, gridZ: z, isGridCell: true };
                cell.receiveShadow = true;
                scene.add(cell);
                gridCells.push(cell);
            }
        }
    }

    function createCastle() {
        const castleGroup = new THREE.Group();
        const endPoint = PATH[PATH.length - 1];
        const castleX = (endPoint.x + 1) * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const castleZ = endPoint.z * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const stoneMat = new THREE.MeshStandardMaterial({ color: 0x6a6a7a, roughness: 0.8 });

        const keep = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 6), stoneMat);
        keep.position.set(0, 4, 0);
        keep.castShadow = true;
        castleGroup.add(keep);

        [{ x: -2.5, z: -2.5 }, { x: 2.5, z: -2.5 }, { x: -2.5, z: 2.5 }, { x: 2.5, z: 2.5 }].forEach(pos => {
            const tower = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.4, 10, 8), stoneMat);
            tower.position.set(pos.x, 5, pos.z);
            tower.castShadow = true;
            castleGroup.add(tower);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 8), new THREE.MeshStandardMaterial({ color: 0x8b0000 }));
            roof.position.set(pos.x, 11.5, pos.z);
            roof.castShadow = true;
            castleGroup.add(roof);
        });

        const battlementGeo = new THREE.BoxGeometry(0.8, 1.5, 0.8);
        for (let i = 0; i < 4; i++) {
            const b1 = new THREE.Mesh(battlementGeo, stoneMat);
            b1.position.set(-2 + i * 1.3, 8.75, -3);
            b1.castShadow = true;
            castleGroup.add(b1);
            const b2 = new THREE.Mesh(battlementGeo, stoneMat);
            b2.position.set(-2 + i * 1.3, 8.75, 3);
            b2.castShadow = true;
            castleGroup.add(b2);
        }

        const gate = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 0.5), new THREE.MeshStandardMaterial({ color: 0x2a1a0a }));
        gate.position.set(0, 1.5, -3.1);
        castleGroup.add(gate);

        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4, 8), new THREE.MeshStandardMaterial({ color: 0x4a3a2a }));
        pole.position.set(0, 12, 0);
        castleGroup.add(pole);
        const banner = new THREE.Mesh(new THREE.PlaneGeometry(2, 1.5), new THREE.MeshStandardMaterial({ color: 0xffd700, side: THREE.DoubleSide }));
        banner.position.set(1.1, 12.5, 0);
        banner.rotation.y = Math.PI / 2;
        castleGroup.add(banner);

        [{ x: -1.5, z: -3.2 }, { x: 1.5, z: -3.2 }].forEach(pos => {
            const torchLight = new THREE.PointLight(0xff6600, 1, 8);
            torchLight.position.set(pos.x, 4, pos.z);
            torchLight.userData = { isTorch: true, baseIntensity: 1 };
            castleGroup.add(torchLight);
            const flame = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), new THREE.MeshBasicMaterial({ color: 0xff4400 }));
            flame.position.set(pos.x, 4.3, pos.z);
            castleGroup.add(flame);
        });

        castleGroup.position.set(castleX, 0, castleZ);
        castleMesh = castleGroup;
        scene.add(castleGroup);
    }

    function createEnvironment() {
        [{ x: -8, z: 5 }, { x: -10, z: 15 }, { x: -6, z: 25 }, { x: 48, z: 8 }, { x: 52, z: 20 }, { x: 45, z: 32 }].forEach(pos => {
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 3, 8), new THREE.MeshStandardMaterial({ color: 0x4a3020 }));
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            tree.add(trunk);
            const foliage = new THREE.Mesh(new THREE.ConeGeometry(2, 5, 8), new THREE.MeshStandardMaterial({ color: 0x1a4a1a }));
            foliage.position.y = 5;
            foliage.castShadow = true;
            tree.add(foliage);
            tree.position.set(pos.x, 0, pos.z);
            scene.add(tree);
        });

        [{ x: -4, z: 10 }, { x: -7, z: 30 }, { x: 46, z: 15 }, { x: 50, z: 28 }].forEach(pos => {
            const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(1 + Math.random(), 0), new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.9 }));
            rock.position.set(pos.x, 0.5, pos.z);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.castShadow = true;
            scene.add(rock);
        });
    }

    function createDustParticles() {
        const particleGeo = new THREE.BufferGeometry();
        const positions = [], velocities = [];
        for (let i = 0; i < 500; i++) {
            positions.push(Math.random() * 80 - 20, Math.random() * 20, Math.random() * 80 - 20);
            velocities.push((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.01, (Math.random() - 0.5) * 0.02);
        }
        particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        particleGeo.userData = { velocities };
        dustParticles = new THREE.Points(particleGeo, new THREE.PointsMaterial({ color: 0x886644, size: 0.15, transparent: true, opacity: 0.4 }));
        scene.add(dustParticles);
    }

    function createTowerModel(type) {
        const tower = new THREE.Group();
        const towerDef = TOWERS[type];

        if (type === 'archer') {
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 3, 8), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
            base.position.y = 1.5;
            base.castShadow = true;
            tower.add(base);
            const platform = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1, 0.5, 8), new THREE.MeshStandardMaterial({ color: 0x6a3a0a }));
            platform.position.y = 3.25;
            tower.add(platform);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(1.3, 1.5, 8), new THREE.MeshStandardMaterial({ color: 0x4a2a0a }));
            roof.position.y = 4.25;
            tower.add(roof);
        } else if (type === 'wizard') {
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.9, 4, 6), new THREE.MeshStandardMaterial({ color: 0x4b0082 }));
            base.position.y = 2;
            tower.add(base);
            const top = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 6), new THREE.MeshStandardMaterial({ color: 0x8b00ff }));
            top.position.y = 5;
            tower.add(top);
            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.5 }));
            orb.position.y = 4.2;
            tower.add(orb);
            tower.add(new THREE.PointLight(0xff00ff, 0.5, 5));
        } else if (type === 'frost') {
            const iceBase = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.9, 2.5, 6), new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.8 }));
            iceBase.position.y = 1.25;
            tower.add(iceBase);
            for (let i = 0; i < 3; i++) {
                const crystal = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 4), new THREE.MeshStandardMaterial({ color: 0x00bfff, transparent: true, opacity: 0.7 }));
                crystal.position.set(Math.sin(i * Math.PI * 2 / 3) * 0.5, 3.5, Math.cos(i * Math.PI * 2 / 3) * 0.5);
                tower.add(crystal);
            }
            const frostLight = new THREE.PointLight(0x00bfff, 0.5, 5);
            frostLight.position.y = 3;
            tower.add(frostLight);
        } else if (type === 'cannon') {
            const cannonBase = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.5, 1.8), new THREE.MeshStandardMaterial({ color: 0x3a3a3a }));
            cannonBase.position.y = 0.75;
            tower.add(cannonBase);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 2, 16), new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.8 }));
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 1.5, -0.5);
            tower.add(barrel);
        } else if (type === 'dragon') {
            const dragonBase = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 2.5, 8), new THREE.MeshStandardMaterial({ color: 0x8b0000 }));
            dragonBase.position.y = 1.25;
            tower.add(dragonBase);
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2, 6), new THREE.MeshStandardMaterial({ color: 0xff4500 }));
            head.rotation.x = Math.PI / 2;
            head.position.set(0, 3, -0.5);
            tower.add(head);
            const dragonLight = new THREE.PointLight(0xff4500, 1, 6);
            dragonLight.position.set(0, 3, -1);
            dragonLight.userData = { isFlame: true, baseIntensity: 1 };
            tower.add(dragonLight);
        } else if (type === 'lightning') {
            const teslaBase = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 2, 8), new THREE.MeshStandardMaterial({ color: 0x4a4a6a, metalness: 0.7 }));
            teslaBase.position.y = 1;
            tower.add(teslaBase);
            const coil = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.1, 8, 16), new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.3 }));
            coil.position.y = 2.5;
            coil.rotation.x = Math.PI / 2;
            tower.add(coil);
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffff00, emissiveIntensity: 0.5 }));
            sphere.position.y = 3.5;
            tower.add(sphere);
            const lightningLight = new THREE.PointLight(0xffff00, 0.8, 6);
            lightningLight.position.y = 3.5;
            lightningLight.userData = { isElectric: true };
            tower.add(lightningLight);
        } else if (type === 'poison') {
            const poisonBase = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.9, 1.5, 8), new THREE.MeshStandardMaterial({ color: 0x2a4a2a }));
            poisonBase.position.y = 0.75;
            tower.add(poisonBase);
            const cauldron = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            cauldron.position.y = 2;
            cauldron.rotation.x = Math.PI;
            tower.add(cauldron);
            const poison = new THREE.Mesh(new THREE.CircleGeometry(0.7, 16), new THREE.MeshStandardMaterial({ color: 0x32cd32, emissive: 0x32cd32, emissiveIntensity: 0.3 }));
            poison.position.y = 2.3;
            poison.rotation.x = -Math.PI / 2;
            tower.add(poison);
            const poisonLight = new THREE.PointLight(0x32cd32, 0.5, 5);
            poisonLight.position.y = 2.5;
            tower.add(poisonLight);
        } else if (type === 'ballista') {
            const ballistaBase = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0x5a4030 }));
            ballistaBase.position.y = 0.5;
            tower.add(ballistaBase);
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 3), new THREE.MeshStandardMaterial({ color: 0x4a3020 }));
            arm.position.set(0, 1.2, 0);
            tower.add(arm);
        } else if (type === 'mortar') {
            const mortarBase = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 1, 8), new THREE.MeshStandardMaterial({ color: 0x3a3a3a }));
            mortarBase.position.y = 0.5;
            tower.add(mortarBase);
            const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 2, 16), new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.6 }));
            tube.position.set(0, 1.5, 0);
            tube.rotation.x = -0.5;
            tower.add(tube);
        } else if (type === 'tesla') {
            const advTeslaBase = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 1.5, 8), new THREE.MeshStandardMaterial({ color: 0x2a2a4a, metalness: 0.8 }));
            advTeslaBase.position.y = 0.75;
            tower.add(advTeslaBase);
            const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 3, 8), new THREE.MeshStandardMaterial({ color: 0x4a4a6a, metalness: 0.9 }));
            pillar.position.y = 2.5;
            tower.add(pillar);
            for (let i = 0; i < 3; i++) {
                const coil = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.08, 8, 16), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.4 }));
                coil.position.y = 2 + i * 0.8;
                coil.rotation.x = Math.PI / 2;
                tower.add(coil);
            }
            const advTeslaLight = new THREE.PointLight(0x00ffff, 0.8, 6);
            advTeslaLight.position.y = 4;
            advTeslaLight.userData = { isElectric: true };
            tower.add(advTeslaLight);
        }

        tower.userData = { type, level: 1, kills: 0 };
        return tower;
    }

    function createEnemyModel(type) {
        const enemyDef = ENEMIES[type];
        const enemy = new THREE.Group();
        const bodyMat = new THREE.MeshStandardMaterial({ color: enemyDef.color });

        // Body (cylinder + spheres for capsule shape - r128 compatible)
        const bodyMain = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.6, 8), bodyMat);
        bodyMain.position.y = 0.8;
        bodyMain.castShadow = true;
        enemy.add(bodyMain);

        const bodyTop = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), bodyMat);
        bodyTop.position.y = 1.1;
        enemy.add(bodyTop);

        const bodyBottom = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), bodyMat);
        bodyBottom.position.y = 0.5;
        enemy.add(bodyBottom);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), bodyMat);
        head.position.y = 1.5;
        enemy.add(head);

        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
        leftEye.position.set(-0.1, 1.55, -0.2);
        enemy.add(leftEye);
        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
        rightEye.position.set(0.1, 1.55, -0.2);
        enemy.add(rightEye);

        const healthBg = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.15), new THREE.MeshBasicMaterial({ color: 0x333333 }));
        healthBg.position.y = 2.2;
        enemy.add(healthBg);
        const healthFill = new THREE.Mesh(new THREE.PlaneGeometry(0.98, 0.12), new THREE.MeshBasicMaterial({ color: 0x44ff44 }));
        healthFill.position.y = 2.2;
        healthFill.position.z = 0.01;
        enemy.add(healthFill);
        enemy.userData.healthBar = healthFill;

        let scale = 1;
        if (type === 'troll' || type === 'golem') scale = 1.5;
        if (type === 'dragon') scale = 1.8;
        if (type === 'boss') scale = 2.5;
        if (type === 'wolf') scale = 0.7;
        if (type === 'skeleton' || type === 'goblin') scale = 0.8;
        enemy.scale.setScalar(scale);

        return enemy;
    }

    function initUI() {
        const towerPanel = document.getElementById('tower-panel');
        Object.entries(TOWERS).forEach(([type, tower]) => {
            const btn = document.createElement('button');
            btn.className = 'tower-btn';
            btn.dataset.type = type;
            btn.innerHTML = `<span class="icon">${tower.icon}</span><span class="name">${tower.name}</span><span class="cost">${tower.cost}g</span>`;
            btn.onclick = () => selectTowerType(type);
            towerPanel.appendChild(btn);
        });

        const skillsPanel = document.getElementById('skills-panel');
        Object.entries(SKILLS).forEach(([type, skill]) => {
            const btn = document.createElement('button');
            btn.className = 'skill-btn';
            btn.dataset.skill = type;
            btn.innerHTML = `${skill.icon}`;
            btn.title = `${skill.name} (${skill.manaCost} mana)`;
            btn.onclick = () => activateSkill(type);
            skillsPanel.appendChild(btn);
        });

        document.getElementById('start-wave-btn').onclick = startWave;
        document.getElementById('pause-btn').onclick = togglePause;
        document.getElementById('speed-btn').onclick = toggleSpeed;
        document.getElementById('upgrade-btn').onclick = upgradeTower;
        document.getElementById('sell-btn').onclick = sellTower;

        renderer.domElement.addEventListener('click', onCanvasClick);
        renderer.domElement.addEventListener('touchend', onCanvasTouch);
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('keydown', onKeyDown);
    }

    function selectTowerType(type) {
        const tower = TOWERS[type];
        if (gameState.gold < tower.cost) return;
        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
        if (gameState.selectedTowerType === type) {
            gameState.selectedTowerType = null;
            hideTowerInfo();
        } else {
            gameState.selectedTowerType = type;
            document.querySelector(`.tower-btn[data-type="${type}"]`).classList.add('selected');
            highlightAvailableCells(true);
        }
    }

    function highlightAvailableCells(highlight) {
        gridCells.forEach(cell => {
            const hasTower = gameState.towers.some(t => t.userData.gridX === cell.userData.gridX && t.userData.gridZ === cell.userData.gridZ);
            if (highlight && !hasTower) {
                cell.material.color.setHex(0x44aa44);
                cell.material.opacity = 0.6;
            } else {
                cell.material.color.setHex(0x1a2a1a);
                cell.material.opacity = 0.3;
            }
        });
    }

    function onCanvasClick(event) { handleInteraction(event.clientX, event.clientY); }
    function onCanvasTouch(event) {
        event.preventDefault();
        if (event.changedTouches.length > 0) {
            const touch = event.changedTouches[0];
            handleInteraction(touch.clientX, touch.clientY);
        }
    }

    function handleInteraction(clientX, clientY) {
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const towerIntersects = raycaster.intersectObjects(gameState.towers, true);
        if (towerIntersects.length > 0) {
            let tower = towerIntersects[0].object;
            while (tower.parent && !tower.userData.type) tower = tower.parent;
            if (tower.userData.type) { selectTower(tower); return; }
        }

        if (gameState.selectedTowerType) {
            const cellIntersects = raycaster.intersectObjects(gridCells);
            if (cellIntersects.length > 0) {
                const cell = cellIntersects[0].object;
                placeTower(cell.userData.gridX, cell.userData.gridZ);
                return;
            }
        }

        gameState.selectedTowerType = null;
        gameState.selectedTower = null;
        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
        highlightAvailableCells(false);
        hideTowerInfo();
    }

    function placeTower(gridX, gridZ) {
        const type = gameState.selectedTowerType;
        const towerDef = TOWERS[type];
        if (gameState.gold < towerDef.cost) return;
        if (gameState.towers.some(t => t.userData.gridX === gridX && t.userData.gridZ === gridZ)) return;

        const tower = createTowerModel(type);
        tower.position.set(gridX * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2, 0, gridZ * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2);
        tower.userData.gridX = gridX;
        tower.userData.gridZ = gridZ;
        tower.userData.lastAttack = 0;
        tower.userData.damage = towerDef.damage;
        tower.userData.range = towerDef.range;
        tower.userData.attackSpeed = towerDef.attackSpeed;
        tower.userData.special = towerDef.special;

        scene.add(tower);
        gameState.towers.push(tower);
        gameState.gold -= towerDef.cost;
        updateUI();

        gameState.selectedTowerType = null;
        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
        highlightAvailableCells(false);
    }

    function selectTower(tower) { gameState.selectedTower = tower; showTowerInfo(tower); }

    function showTowerInfo(tower) {
        const info = document.getElementById('tower-info');
        const type = tower.userData.type;
        const towerDef = TOWERS[type];
        document.getElementById('tower-info-name').textContent = towerDef.name + ' Tower';
        document.getElementById('tower-info-level').textContent = tower.userData.level;
        document.getElementById('tower-info-damage').textContent = tower.userData.damage.toFixed(0);
        document.getElementById('tower-info-range').textContent = tower.userData.range.toFixed(1);
        document.getElementById('tower-info-speed').textContent = tower.userData.attackSpeed.toFixed(1);
        document.getElementById('tower-info-kills').textContent = tower.userData.kills;
        const upgradeCost = Math.floor(towerDef.cost * 0.5 * tower.userData.level);
        document.getElementById('upgrade-btn').textContent = `Upgrade (${upgradeCost}g)`;
        const sellValue = Math.floor(towerDef.cost * 0.5);
        document.getElementById('sell-btn').textContent = `Sell (${sellValue}g)`;
        info.style.left = '10px';
        info.style.top = '100px';
        info.classList.add('visible');
    }

    function hideTowerInfo() { document.getElementById('tower-info').classList.remove('visible'); }

    function upgradeTower() {
        const tower = gameState.selectedTower;
        if (!tower) return;
        const type = tower.userData.type;
        const towerDef = TOWERS[type];
        const upgradeCost = Math.floor(towerDef.cost * 0.5 * tower.userData.level);
        if (gameState.gold < upgradeCost) return;
        gameState.gold -= upgradeCost;
        tower.userData.level++;
        tower.userData.damage *= 1.3;
        tower.userData.range *= 1.1;
        tower.userData.attackSpeed *= 1.1;
        tower.scale.multiplyScalar(1.05);
        updateUI();
        showTowerInfo(tower);
    }

    function sellTower() {
        const tower = gameState.selectedTower;
        if (!tower) return;
        const type = tower.userData.type;
        const towerDef = TOWERS[type];
        const sellValue = Math.floor(towerDef.cost * 0.5);
        gameState.gold += sellValue;
        scene.remove(tower);
        const index = gameState.towers.indexOf(tower);
        if (index > -1) gameState.towers.splice(index, 1);
        gameState.selectedTower = null;
        hideTowerInfo();
        updateUI();
    }

    function activateSkill(type) {
        const skill = SKILLS[type];
        if (gameState.skillCooldowns[type] && Date.now() < gameState.skillCooldowns[type]) return;
        if (gameState.mana < skill.manaCost) return;
        gameState.mana -= skill.manaCost;
        gameState.skillCooldowns[type] = Date.now() + skill.cooldown * 1000;

        if (type === 'meteor' && gameState.enemies.length > 0) {
            const target = gameState.enemies[Math.floor(Math.random() * gameState.enemies.length)];
            gameState.enemies.forEach(enemy => {
                const dist = enemy.position.distanceTo(target.position);
                if (dist < skill.radius * CONFIG.CELL_SIZE) damageEnemy(enemy, skill.damage);
            });
            showMessage('Meteor Strike!');
        } else if (type === 'blizzard') {
            gameState.blizzardActive = true;
            gameState.blizzardEndTime = Date.now() + skill.duration * 1000;
            showMessage('Blizzard!');
        } else if (type === 'heal') {
            gameState.health = Math.min(CONFIG.STARTING_HEALTH, gameState.health + skill.healAmount);
            showMessage('+' + skill.healAmount + ' HP');
        } else if (type === 'rage') {
            gameState.rageActive = true;
            gameState.rageEndTime = Date.now() + skill.duration * 1000;
            showMessage('RAGE!');
        }
        updateUI();
        updateSkillCooldowns();
    }

    function updateSkillCooldowns() {
        document.querySelectorAll('.skill-btn').forEach(btn => {
            const skillType = btn.dataset.skill;
            const cooldownEnd = gameState.skillCooldowns[skillType];
            if (cooldownEnd && Date.now() < cooldownEnd) {
                btn.classList.add('cooldown');
                const remaining = Math.ceil((cooldownEnd - Date.now()) / 1000);
                let cdOverlay = btn.querySelector('.cd-overlay');
                if (!cdOverlay) { cdOverlay = document.createElement('span'); cdOverlay.className = 'cd-overlay'; btn.appendChild(cdOverlay); }
                cdOverlay.textContent = remaining + 's';
            } else {
                btn.classList.remove('cooldown');
                const cdOverlay = btn.querySelector('.cd-overlay');
                if (cdOverlay) cdOverlay.remove();
            }
        });
    }

    function togglePause() {
        gameState.paused = !gameState.paused;
        document.getElementById('pause-btn').classList.toggle('active', gameState.paused);
        document.getElementById('pause-btn').innerHTML = gameState.paused ? '&#9654;' : '&#9208;';
    }

    function toggleSpeed() {
        gameState.gameSpeed = gameState.gameSpeed === 1 ? 2 : 1;
        document.getElementById('speed-btn').textContent = gameState.gameSpeed + 'x';
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
        if (event.key === ' ' || event.key === 'Spacebar') { event.preventDefault(); if (!gameState.waveActive) startWave(); }
        if (event.key === 'p' || event.key === 'P') togglePause();
        if (event.key === 'Escape') {
            gameState.selectedTowerType = null;
            gameState.selectedTower = null;
            document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
            highlightAvailableCells(false);
            hideTowerInfo();
        }
    }

    function startWave() {
        if (gameState.waveActive || gameState.wave >= CONFIG.MAX_WAVES) return;
        gameState.wave++;
        gameState.waveActive = true;
        document.getElementById('start-wave-btn').style.display = 'none';
        showMessage('Wave ' + gameState.wave);
        const waveConfig = WAVES[gameState.wave - 1];
        let totalEnemies = 0;
        waveConfig.enemies.forEach(group => {
            for (let i = 0; i < group.count; i++) {
                setTimeout(() => spawnEnemy(group.type), totalEnemies * waveConfig.delay);
                totalEnemies++;
            }
        });
        updateUI();
    }

    function getScaledHealth(baseHealth, wave) {
        return Math.floor(baseHealth * Math.pow(1.12, wave - 1));
    }

    function spawnEnemy(type) {
        const enemyDef = ENEMIES[type];
        if (!enemyDef) { console.error('Unknown enemy type:', type); return; }
        const enemy = createEnemyModel(type);
        const startPoint = PATH[0];
        enemy.position.set(startPoint.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2, 0, startPoint.z * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2);
        const scaledHealth = getScaledHealth(enemyDef.health, gameState.wave);
        enemy.userData = {
            type, health: scaledHealth, maxHealth: scaledHealth, speed: enemyDef.speed,
            reward: enemyDef.reward, armor: enemyDef.armor || 0, shield: enemyDef.shield || 0,
            pathIndex: 0, effects: {}, healthBar: enemy.userData.healthBar
        };
        scene.add(enemy);
        gameState.enemies.push(enemy);
    }

    function updateEnemies(deltaTime) {
        const speed = deltaTime * 0.003 * gameState.gameSpeed;
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const enemy = gameState.enemies[i];
            let moveSpeed = enemy.userData.speed;
            if (gameState.blizzardActive) moveSpeed *= 0.5;
            if (enemy.userData.effects.slow && Date.now() < enemy.userData.effects.slow.endTime) moveSpeed *= enemy.userData.effects.slow.amount;
            if (enemy.userData.effects.poison && Date.now() < enemy.userData.effects.poison.endTime) {
                if (!enemy.userData.effects.poison.lastTick || Date.now() - enemy.userData.effects.poison.lastTick > 1000) {
                    damageEnemy(enemy, enemy.userData.effects.poison.damage);
                    enemy.userData.effects.poison.lastTick = Date.now();
                }
            }
            if (enemy.userData.effects.burn && Date.now() < enemy.userData.effects.burn.endTime) {
                if (!enemy.userData.effects.burn.lastTick || Date.now() - enemy.userData.effects.burn.lastTick > 500) {
                    damageEnemy(enemy, enemy.userData.effects.burn.damage);
                    enemy.userData.effects.burn.lastTick = Date.now();
                }
            }

            if (enemy.userData.pathIndex < PATH.length - 1) {
                const currentTarget = PATH[enemy.userData.pathIndex + 1];
                const targetPos = new THREE.Vector3(currentTarget.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2, 0, currentTarget.z * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2);
                const direction = new THREE.Vector3().subVectors(targetPos, enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(speed * moveSpeed));
                enemy.lookAt(targetPos);
                if (enemy.position.distanceTo(targetPos) < 0.3) enemy.userData.pathIndex++;
            } else {
                gameState.health -= 10;
                removeEnemy(enemy, i, false);
                if (gameState.health <= 0) { gameOver(false); return; }
            }

            if (enemy.userData.healthBar) {
                const healthPercent = enemy.userData.health / enemy.userData.maxHealth;
                enemy.userData.healthBar.scale.x = healthPercent;
                enemy.userData.healthBar.position.x = (healthPercent - 1) * 0.49;
                enemy.userData.healthBar.material.color.setHex(healthPercent > 0.6 ? 0x44ff44 : healthPercent > 0.3 ? 0xffff44 : 0xff4444);
                enemy.userData.healthBar.parent.lookAt(camera.position);
            }
        }
        if (gameState.waveActive && gameState.enemies.length === 0) waveComplete();
    }

    function damageEnemy(enemy, damage) {
        let actualDamage = damage - (enemy.userData.armor || 0);
        if (actualDamage < 1) actualDamage = 1;
        if (gameState.rageActive) actualDamage *= 2;
        if (enemy.userData.shield > 0) {
            if (enemy.userData.shield >= actualDamage) { enemy.userData.shield -= actualDamage; return; }
            actualDamage -= enemy.userData.shield;
            enemy.userData.shield = 0;
        }
        enemy.userData.health -= actualDamage;
        if (enemy.userData.health <= 0) {
            const index = gameState.enemies.indexOf(enemy);
            if (index > -1) removeEnemy(enemy, index, true);
        }
    }

    function removeEnemy(enemy, index, killed) {
        if (killed) { gameState.gold += enemy.userData.reward; gameState.totalKills++; }
        scene.remove(enemy);
        gameState.enemies.splice(index, 1);
        updateUI();
    }

    function updateTowers(deltaTime) {
        const now = Date.now();
        gameState.towers.forEach(tower => {
            const attackInterval = 1000 / tower.userData.attackSpeed;
            if (now - tower.userData.lastAttack < attackInterval / gameState.gameSpeed) return;
            let target = null, closestDist = tower.userData.range * CONFIG.CELL_SIZE;
            gameState.enemies.forEach(enemy => {
                const dist = tower.position.distanceTo(enemy.position);
                if (dist < closestDist) { closestDist = dist; target = enemy; }
            });
            if (target) {
                tower.userData.lastAttack = now;
                attackEnemy(tower, target);
            }
        });
    }

    function attackEnemy(tower, target) {
        const damage = tower.userData.damage;
        damageEnemy(target, damage);
        if (target.userData.health <= 0 && tower) tower.userData.kills++;

        const special = tower.userData.special;
        if (special === 'slow') target.userData.effects.slow = { amount: 0.5, endTime: Date.now() + 3000 };
        else if (special === 'burn') target.userData.effects.burn = { damage: damage * 0.2, endTime: Date.now() + 4000 };
        else if (special === 'dot') target.userData.effects.poison = { damage: damage * 0.3, endTime: Date.now() + 5000 };
        else if (special === 'splash' || special === 'aoe') {
            gameState.enemies.forEach(enemy => {
                if (enemy !== target && enemy.position.distanceTo(target.position) < CONFIG.CELL_SIZE * 2) damageEnemy(enemy, damage * 0.5);
            });
        } else if (special === 'chain') {
            let chainCount = 0;
            gameState.enemies.forEach(enemy => {
                if (enemy !== target && chainCount < 2 && enemy.position.distanceTo(target.position) < CONFIG.CELL_SIZE * 3) {
                    damageEnemy(enemy, damage * 0.5);
                    chainCount++;
                }
            });
        } else if (special === 'stun') target.userData.effects.slow = { amount: 0.1, endTime: Date.now() + 1500 };
        else if (special === 'pierce') {
            gameState.enemies.forEach(enemy => {
                if (enemy !== target && enemy.position.distanceTo(target.position) < CONFIG.CELL_SIZE * 2) damageEnemy(enemy, damage * 0.7);
            });
        } else if (special === 'arc') {
            for (let j = 0; j < 3; j++) {
                const nearby = gameState.enemies.filter(e => e.position.distanceTo(tower.position) < CONFIG.CELL_SIZE * 3);
                if (nearby.length > 0) damageEnemy(nearby[Math.floor(Math.random() * nearby.length)], damage * 0.3);
            }
        }
    }

    function waveComplete() {
        gameState.waveActive = false;
        const waveBonus = gameState.wave * 20;
        gameState.gold += waveBonus;
        showMessage('Wave Complete! +' + waveBonus + 'g');
        if (gameState.wave >= CONFIG.MAX_WAVES) gameOver(true);
        else document.getElementById('start-wave-btn').style.display = 'block';
        updateUI();
    }

    function gameOver(victory) {
        if (victory) {
            document.getElementById('victory-kills').textContent = gameState.totalKills;
            document.getElementById('victory-gold').textContent = gameState.gold;
            document.getElementById('victory-screen').classList.add('visible');
        } else {
            document.getElementById('defeat-wave').textContent = gameState.wave;
            document.getElementById('defeat-kills').textContent = gameState.totalKills;
            document.getElementById('defeat-screen').classList.add('visible');
        }
    }

    function showMessage(text) {
        const area = document.getElementById('message-area');
        area.innerHTML = `<div class="game-message">${text}</div>`;
        setTimeout(() => { area.innerHTML = ''; }, 2000);
    }

    function updateUI() {
        document.getElementById('gold-display').textContent = gameState.gold;
        document.getElementById('health-display').textContent = Math.max(0, gameState.health);
        document.getElementById('mana-display').textContent = Math.floor(gameState.mana);
        document.getElementById('wave-display').textContent = gameState.wave;
        document.querySelectorAll('.tower-btn').forEach(btn => {
            const type = btn.dataset.type;
            const cost = TOWERS[type].cost;
            btn.classList.toggle('disabled', gameState.gold < cost);
        });
    }

    let lastTime = 0;
    function animate(currentTime) {
        requestAnimationFrame(animate);
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        if (!gameState.paused) {
            gameState.mana = Math.min(CONFIG.MAX_MANA, gameState.mana + CONFIG.MANA_REGEN * deltaTime / 1000 * gameState.gameSpeed);
            if (gameState.rageActive && Date.now() > gameState.rageEndTime) gameState.rageActive = false;
            if (gameState.blizzardActive && Date.now() > gameState.blizzardEndTime) gameState.blizzardActive = false;

            updateEnemies(deltaTime);
            updateTowers(deltaTime);

            if (dustParticles) {
                const positions = dustParticles.geometry.attributes.position.array;
                const velocities = dustParticles.geometry.userData.velocities;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i];
                    positions[i + 1] += velocities[i + 1];
                    positions[i + 2] += velocities[i + 2];
                    if (positions[i] > 60) positions[i] = -20;
                    if (positions[i] < -20) positions[i] = 60;
                    if (positions[i + 1] > 20) positions[i + 1] = 0;
                    if (positions[i + 1] < 0) positions[i + 1] = 20;
                    if (positions[i + 2] > 60) positions[i + 2] = -20;
                    if (positions[i + 2] < -20) positions[i + 2] = 60;
                }
                dustParticles.geometry.attributes.position.needsUpdate = true;
            }

            gameState.towers.forEach(tower => {
                tower.children.forEach(child => {
                    if (child.isPointLight) {
                        if (child.userData.isFlame || child.userData.isTorch) child.intensity = child.userData.baseIntensity * (0.8 + Math.random() * 0.4);
                        if (child.userData.isElectric) child.intensity = 0.5 + Math.random() * 0.5;
                    }
                });
            });

            if (castleMesh) {
                castleMesh.children.forEach(child => {
                    if (child.isPointLight && child.userData.isTorch) child.intensity = child.userData.baseIntensity * (0.7 + Math.random() * 0.6);
                });
            }

            if (starField) starField.rotation.y += 0.0001;
        }

        updateUI();
        updateSkillCooldowns();
        renderer.render(scene, camera);
    }

    function initMenu() {
        document.getElementById('startGameBtn').addEventListener('click', () => {
            document.getElementById('menuScreen').classList.add('hidden');
            init();
        });

        document.getElementById('howToPlayBtn').addEventListener('click', () => {
            document.getElementById('howToPlayModal').classList.remove('hidden');
        });

        document.getElementById('closeHowTo').addEventListener('click', () => {
            document.getElementById('howToPlayModal').classList.add('hidden');
        });
    }

    function init() {
        initThreeJS();
        initUI();
        animate(0);
    }

    // Initialize menu on load, wait for start button
    initMenu();

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        });
    }
    </script>
</body>
</html>
